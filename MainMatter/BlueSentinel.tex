% ------------------------------------------------------------------------ %
% !TEX encoding = UTF-8 Unicode
% !TEX TS-program = pdflatex
% !TEX root = ../Tesi.tex
% !TEX spellcheck = it-IT
% ------------------------------------------------------------------------ %
%
% ------------------------------------------------------------------------ %
% 	NOME CAPITOLO
% ------------------------------------------------------------------------ %
%
\chapter[BlueSentinel: the Occupancy Monitoring System]{BlueSentinel: the Proposed Occupancy Monitoring System}
\chaptermark{The BlueSentinel System}
%\markboth{The BlueSentinel System}{The BlueSentinel System}	% headings
%
\label{cap:bluesentinel}

%\section{Introduction}
%\label{sec:intro}

%Smart buildings are environments like offices or schools able to exploit sensors, devices and appliances to observe users activity and adapt autonomously to achieve comfort, safety and energy efficiency. Considering the fast development of technologies for connected sensor and actuator (the so called \emph{Internet of Things}), since few years smart buildings are becoming a reality from a technological point of view.

%\medskip
One of the main components of a smart building is the \textbf{Occupancy Monitoring system}, i.e. a system able to detect the number (or even the identity) of the occupants in every room or zone of the building. Occupants play a key role in the objectives of smart buildings. User comfort can be improved controlling automatically the environment temperature, humidity, and brightness, setting all the parameters exploiting user defined preferences. In this scenario, user identification and localization inside the building is fundamental.\\
In order to guarantee the building safety, the knowledge of the occupants position in real-time can be precious. In case of emergencies like fires, escape routes and emergency exits might be highlighted with notifications targeted to the specific user's location.\\
Probably, the main purpose of smart buildings, or in this case also called green buildings, is energy sustainability.
In 2010, heating, ventilation, and air-conditioning (HVAC) consumed 42\% of the energy used in the United States.
At this purpose, in the last few years plenty of methods have been proposed to control HVAC systems based on real-time occupancy information or learning the occupants habits to forecast the energy consumption.

\medskip
The expected outcome of an occupancy monitoring system is the detection in real-time (or with a tolerable delay) of every user inside the building, with their position. Usually, the occupant needs to be localized in a zone or room of the building, since this information is sufficient to automatize HVAC and lighting systems. In cases of automation based on user-defined preferences also the identification of each user is required by the system.

\smallskip
As explained in chapter \ref{cap:soa}, a lot of effort has been put both from the industry and the academia in terms of research and product industrialization. However, some intrinsically hard challenges of the occupancy monitoring problem bring to the lack of an accessible solution with broad adoption.

In this chapter is presented BlueSentinel, an occupancy monitoring system developed with the aim to improve the shortcomings identified in the state of the art. In particular, the BlueSentinel project aims at providing a monitoring system able to run continuously and for long execution times, limiting the intrusiveness on the occupants of the building. In order to achieve these requirements, the system has been developed exploiting at low level the Bluetooth Low Energy protocol. The architecture of the system derives from traditional indoor positioning systems; however, passive transmitting nodes (such as beacons) have been replaced with active nodes, composing a sort of wireless sensor network.

During this chapter, the different layers and components of the system are described. In chapter \ref{cap:results} are presented the experimental results, suggesting that the proposed approach is valid and promising.

\section{Choosing the Enabling Technology}
\label{sec:technology}
In the {\hyperref[cap:soa]{previous chapter}}, many possible technological solutions to build indoor location monitoring systems have been reviewed. During the preliminary analysis of our work, all the available technologies have been considered in order to satisfy the occupancy monitoring requirements and a feasible solution for both users and infrastructures.

Considering the comparison summarized in table \ref{tab:od_soa}, it can be deduced that the only solutions able to guarantee a true real-time detection of users are cameras and wireless based solutions. When comparing this two approaches, cameras revealed to have many more drawbacks with respect to wireless solutions.
Camera based systems require a high computational effort to perform real-time body recognition on indoor video (or images) streams. The compute-intensive peculiarity makes the approach not suitable to scale up for large buildings, with tens or thousand rooms and users.
Wireless based solutions tend to provide easily an outcome in real-time, or with a tolerable delay. Raw data produced by wireless systems is usually far more lightweight to process (for example compared to images), making the solution attractive for large indoor areas.

\smallskip
Inside the wireless scope, the choice is restricted to technologies that all users have already available in their mobile devices, so to avoid the employment of additional objects. The first one is certainly WiFi. WiFi based localization solutions have been deeply investigated, also because of WiFi infrastructure is already present in almost all buildings. However, for monitoring purposes, they are not able to provide real-time location data for long execution periods. This issue is explained in detail in section \ref{subsec:wips_od} and summarized here.\\
There exist two ways to localize a mobile device using WiFi connectivity, an \emph{active} and a \emph{passive} method. The active method requires an application installed on mobile device that keeps an active connection with all the surrounding hotspots, and continuously notify collected data using an Internet connection. However, battery consumption related to WiFi operations is too high to reach many hours of execution.\\
The passive method instead doesn't require any installed application on mobile device, but simply exploits WiFi packets sent from devices during their usual activity. Unfortunately, using this approach, is nearly impossible to obtain real-time detection since mobile operating systems apply aggressive sleep policies to WiFi module in order to limit consumptions. A WiFi connected smartphone during sleep can spend several minutes without emits any signal, making the system unresponsive to users movements \cite{Balaji2013}.

\smallskip
The remaining available wireless technology is Bluetooth, and in particular Bluetooth Low Energy. Since 2010, BLE chips (able to work with classic and Low Energy enabled Bluetooth) have been built into in an increasing number of smartphones, tablets or wearables (as instance, Apple has incorporated them in its products since the iPhone 4S in 2011).
Devices using BLE consume ten times less then WiFi and a fraction of the power of classic Bluetooth \cite{Choperena2013}.
However, at the best of our knowledge, BLE has been employed for localization only through passive appliances (like beacons) that leave the burden on the mobile device, forcing it to run positioning algorithms continuously and notify the result through energy-hungry connectivities.
In order to fully exploit energy efficiency of BLE, the proposed system relies on BLE mobile advertisement (section \ref{sec:advertisement}), a particular BLE signal transmission compatible with almost all mobile devices since few years.
%With the diffusion in the last few years of devices enabled with peripheral mode BLE chipset, BLE advertisement becomes possible on mobile devices
%This makes BLE an excellent technology for a real-time positioning solution.


\section{Mobile BLE Advertisement}
\label{sec:advertisement}
As explained in section \ref{subsec:BLEprotocol}, BLE specification divides Bluetooth devices in two classes: \emph{Central} and \emph{Peripheral} devices (figure \ref{fig:cent-per}). Peripheral devices generates data, like sensor readings or audio streams, while Central devices consumes it. This BLE specification was intended to classify smartphones and PC as centrals, while accessories as peripherals.

BLE has also two ways of communicating. The first way is establishing a \emph{Connection} between a peripheral and a central device. Every connection however, requires a preliminary pairing phase between the two devices. This makes unfeasible the employment of BLE connections in monitoring applications, since a mobile device (central) would be forced to perform a pairing with every single reference node (peripheral) before monitoring can start.

\begin{figure}[h!tb]
\centering
\includegraphics[width=0.8\linewidth]{central-peripheral2.pdf}
\caption[Central and Peripheral devices in BLE specification and the implemented system.]{Central and Peripheral devices in BLE specification compared with the implemented system.}
\label{fig:cent-per}
\end{figure}

The second possible way to communicate is using \emph{Advertisement}, where a BLE peripheral device broadcasts packets to every device around it. The receiving device can then act on this information.
Advertising that is by design unidirectional can be performed exclusively by peripheral devices.
For localization purposes, advertisement devices known as beacons as been employed as reference nodes; however, for localization purposes, this approach leaves the burden on the mobile device, forcing it to run positioning algorithms continuously and notify the result through energy-hungry connectivities (more details in section \ref{subsec:wips_od}).\\
The key idea behind the proposed system is to use smartphones as BLE peripheral devices, while reference nodes as BLE central devices (fig. \ref{fig:cent-per}). In this way, user devices are able to advertise them-self in a given position of the building without any connection or pairing, while reference nodes collect all the received advertisement packets.

\begin{figure}[h!tb]
\centering
\includegraphics[width=0.65\linewidth]{payload.pdf}
\caption[BLE advertisement packet contents.]{BLE advertisement packet contents.}
\label{fig:payload}
\end{figure}

As shown in figure \ref{fig:payload}, advertisement packets contain the Bluetooth MAC address of the device and a very limited custom payload of 31 bytes. Since we need to identify the user, a straightforward solution would be to associate each MAC address with a registered user. However this is no longer possible on recent versions of Android and iOS since they hide MAC addresses to developers in order to increase user's privacy. For this reason, a Universally Unique IDentifier (UUID) has been employed to recognize each user advertisement.
At the same way in which UUIDs have been used to advertise regions through BLE beacons (like the Apple iBeacon), occupants of a building can be localized and identified in real-time associating each UUID with a building user.

\smallskip
BLE advertisement on mobile devices requires a specific hardware, the BLE peripheral mode chipset. Fortunately, almost all current devices have built-in peripheral chipset: all Apple devices since iPhone 4S and iPad 3, about 80\% of all Android devices released in 2014 and about 90\% in 2015 \cite{RadiusNetwork2016}.
%A Central device can't send any data to the Peripheral device without a connection. But a single peripheral can advertise to multiple masters in the area.

\medskip
The proposed system has been developed using smartphones as advertising devices. However, The same advertising task can be easily implemented on wearable devices like smart-watch, that are natively build as BLE peripheral devices. The employment of wearable devices for occupancy monitoring would be even more effective, since they never separate from their users.

\section{System Overview}
\label{sec:overview}
In this section, the architecture of the proposed system will be over-viewed, while in the next three sections every components will be explained in detail.

The proposed location monitoring system is composed by three main parts (figure \ref{fig:bs-protocol}).

\begin{figure}[h!tb]
\centering
\includegraphics[width=\linewidth]{bs-protocol.pdf}
\caption[Overview of the BlueSentinel occupancy monitoring system.]{Overview of the BlueSentinel occupancy monitoring system. A mobile application perform advertising over BLE. Packets are collected by a network of sensor nodes and analyzed by a centralized system.}
\label{fig:bs-protocol}
\end{figure}

\begin{itemize}
\item First, the \textbf{mobile application} that runs on users mobile devices. The application manages registrations and logins of users (necessary to detect occupants identity) and performs the BLE advertisement. For both Android and iOS devices, it's possible to perform BLE advertisement even during device sleep and when the application is in background.
During BLE advertisement the application is free from any localization algorithm, Internet connection or GPS service, to preserve battery and to bother users as least as possible.

\item The component that directly interacts with occupants mobile devices is a network of Bluetooth Low Energy \textbf{receiver nodes}. This nodes, positioned by the building administrator during the system installation, are in charge of collecting BLE packets coming from occupants, together with signal features (like the received power) useful to estimate their position. The information collected by each node is rapidly forwarded through an Internet connection toward a centralized Building Management System.

\item All the information collected by the sensor nodes are merged at the back-end level by the \textbf{Building Management System} (BMS). Here signal features related to every occupant is reconstructed and compared to a database of training data to estimate their position. In particular, different classification algorithms have been implemented to locate each users in the best fitting zone or room. Real-time and historical data occupancy is then exposed by the BMS for a web-based monitoring and third-party applications through a REST API.
\end{itemize}

\begin{figure*}
\center
\minipage{0.50\textwidth}
\center
  \includegraphics[width=0.8\linewidth]{bsscreen1.pdf}
\endminipage
\minipage{0.50\textwidth}
\center
  \includegraphics[width=0.8\linewidth]{bsscreen2.pdf}
\endminipage
  \caption{Mobile application developed for Android and iOS devices.}\label{fig:bsscreen}
\end{figure*}

\section{Mobile Application}
\label{sec:app}
A mobile application for both Android and iOS devices has been developed for BlueSentinel users and released on the respective store \cite{NECSTboxAndroid, NECSTboxIos} (Figure \ref{fig:bsscreen}).

The application manages users registrations to the system, asking for e-mail, username and password. Registration has been set up as mandatory; in this way the system is enabled for user identification, but also to build historical data and occupancy probability profiles per single occupant.\\
For each registered user, the system generates an identification string of 10 characters (for example \verb|userId=tslJp2hnqf|). This identifier will be used for both database key and advertisement UUID (Universally Unique IDentifier).

\lstset{
  basicstyle=\ttfamily\footnotesize,
  language=Java,
  columns=fullflexible,
  keepspaces=true,
}

The BlueSentinel menu let the user manage the Bluetooth functionality. Here BLE advertisement can be turn on and off.
In the Android environment BLE advertisement in background is supported by simply implementing the \verb|BluetoothLeAdvertiser| class in an Android Service. The essential code for the advertisement is reported in listing \ref{lst:androidAdv}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={BLE advertising of user identification for Android devices.}, label={lst:androidAdv}]
    private void startAdvertising() {
    		// Retrieve user identification string from database
        String userId = ParseUser.getCurrentUser().getObjectId();
        ParcelUuid pUuid = new ParcelUuid(UUID.fromString(UuidFromString("BLSNTL" + userId)));

        bleAdvertiser = BluetoothAdapter.getDefaultAdapter().getBluetoothLeAdvertiser();
        AdvertiseSettings settings = new AdvertiseSettings.Builder()
        				// Balanced transmission frequency
                .setAdvertiseMode(AdvertiseSettings.MODE_BALANCED)
                // High transmission power
                .setTxPowerLevel(AdvertiseSettings.TX_POWER_HIGH)
                // No time limit
                .setTimeout(0)
                .setConnectable(false)

        AdvertiseData data = new AdvertiseData.Builder()
        		.addServiceUuid(pUuid)
                .setIncludeDeviceName(false)
        bleAdvertiser.startAdvertising(settings, data, advCallback);
    }
\end{lstlisting}
\end{minipage}

User identification string is retrieved from database, converted into a 128-bit UUID and added to the advertisement data. An identification token ("\verb|BLSNTL|") is used as prefix in the UUID; the purpose of the prefix is to discriminate BlueSentinel UUIDs from packets advertised by unrelated devices in the environment, such as BLE headphones or wristbands. Considering 6 chars for the prefix, and the 10 chars of the id, the string of 16 characters can be contained in the 16 bytes of the UUID using the 8-bit ASCII encoding. The resulting Bluetooth packet is represented in figure \ref{fig:payload-detail}.

\begin{figure}[h!tb]
\centering
\includegraphics[width=0.6\linewidth]{payload-detail.pdf}
\caption[Detail of the BLE packet advertised by each BlueSentinel user.]{Detail of the BLE packet advertised by each BlueSentinel user.}
\label{fig:payload-detail}
\end{figure}

\medskip
In iOS SDK beacon functionalities are implemented in the CoreLocation framework, which supports all that it is needed to replicate beacons through an iDevice.
However, the CoreLocation framework places many limits on how it can be used in the background.\\
The application has been implemented exploiting the CoreBluetooth framework, that has much greater background support of iOS apps. With CoreBluetooth, it's possible to broadcast as a peripheral and detect as a central while in the background. The Objective-C code that performs the advertising is similar to the equivalent \ref{lst:androidAdv}, where the \verb|CBPeripheralManager| take the place of the \verb|BluetoothLeAdvertiser| class.


\medskip
In addition to the application for building users, a separate application has been developed for the building administrator in order to perform the training of the classification algorithm. The training requires the creation of a label for each building zone; then the administrator needs to travel across each building zone, stop for some seconds and declare the correct room label. Meanwhile, on the server side, the training phase creates a set of RSS samples, each one of them labeled with the corresponding ground truth location.

\section{Wireless Sensor Network}
\label{sec:wsn}
On the building side, the system requires a set of hardware nodes deployed in the indoor environment able to collect BLE packets and contact a centralized server. The node prototype has been developed using Raspberry Pi 3, one of the most cheapest board that supports all the necessary connections. In particular, the mentioned single-board computer provide a BLE module, and both WiFi and Ethernet for Internet connections.

\begin{figure}[h!tb]
\centering
\includegraphics[width=0.6\linewidth]{raspberry.png}
\caption[Prototype of BlueSentinel sensor nodes using Raspberry Pi 3 boards.]{Prototype of BlueSentinel sensor nodes using Raspberry Pi 3 boards.}
\label{fig:raspberry}
\end{figure}

Raspberry boards support a Debian-based Linux distribution, that has been used for the BlueSentinel nodes. The routine that runs continuously on each board has been written in Python, since the most supported library to manage BLE connections is provided for that language. The routine is divided in three concurrent threads:

\begin{itemize}
\item \textbf{BLE scan}: a thread is in charge of collecting every single BLE advertising signal coming from BlueSentinel users. Received packets are first filtered, searching for the BlueSentinel token inside the packet payload. All the unidentified signals are discarded, while the useful packets are stored in a queue. In particular, for each BlueSentinel packet, the thread stores the user Id, the corresponding Received Signal Strength (RSS) expressed in dBm (Decibel-milliwatt), and a timestamp representing the receiving instant.
\item \textbf{Filtering}: Like any other indoor radio-frequency signal, BLE advertisement suffer from signal fluctuations due to multipath fading. This cause a signal to fluctuate over time even if the transmitter is stationary at a fixed distance from the receiver. To reduce the error caused by fluctuations a low-pass filter is applied to the signal received by each user. The filter implemented is the Exponentially Weighted Moving Average (EWMA) that applies weighting factors to the RSS which decrease exponentially over time. Since any filter applied to smooth the signal will always introduce a delay, the EWMA filter has been selected to prioritize more recent RSS samples. The value $V_t$ is computed at time instant $t$ with the following equation:

\begin{equation}\label{eq:filter}
V_t = \alpha \cdot RSS_t + (1 - \alpha) \cdot RSS_{t-1}
\end{equation}

The weighting for each older datum decreases exponentially, never reaching zero. The $\alpha$ coefficient has been fixed to 0.85.
\item \textbf{Data push}: the third thread is is in charge of pushing RSS values periodically to the server at regular intervals. In particular, in each cycle and for each user detected, this thread send the user id, the filtered RSS values, and the most recent timestamp within the sliding window of the EWMA filter.
The choice of the timestamp is given by the weighting factor that emphasizes exponentially the more recent sample. The server is contacted with a HTTP request.
After that data is pushed to the server, the thread empty the samples queue, so that new signals coming from BLE scan will be evaluated in a new filtering window.
After some attempts with different intervals, the period has been set to 1.5 seconds.
\end{itemize}

Every nodes has been connected to the building LAN infrastructure and set up to be remotely accessed using SSH. Every relevant operation executed by the mentioned threads has been logged in a file, in order to check 

\section{Back-end}
\label{sec:back-end}
The system back-end has been set up using Parse-Server, an open-source API server based on the Express web application framework. The REST API has been exploited to interact with Parse Server from the mobile applications, sensor nodes, and a web page. The JavaScript SDK provided by Parse Server (called Cloud Code) has been used to manage the creation of database objects and the localization algorithm.\\
The system back-end has been structured to provide the building occupancy information through the REST API to any third party components of the Building Management System able to send HTTP requests.

All the platforms used to develop the back-end and the external components are represented in figure~\ref{fig:platforms}.

\begin{figure}[h!tb]
\centering
\includegraphics[width=0.9\linewidth]{platforms.pdf}
\caption[Platforms employed for the system back-end and the external components.]{Platforms employed for the system back-end and the external components.}
\label{fig:platforms}
\end{figure}

\subsection{Database}
\label{subsec:db}

The database that supports the system has been implemented using MongoDB. The database contains user objects created during registration. Each zone (or room) of the building has its own instance, created during the training phase by the administrator application. The ReceivedSignal object is created directly by the sensor nodes. It represents the reception of a BLE signal, by a given node. The object is created with the user id founded in the signal, and the received signal strength. The ReceivedSignal data is used by the fingerprinting algorithm to compute each user position. Whenever this happens, the outcome is stored using the UserPosition object.

\begin{table}[h!tb]
\caption[BlueSentinel back-end database.]{BlueSentinel back-end database. Underlined fields represent keys of the table.}
\label{tab:db}
\begin{tabular}{c | c c c c}
%\hline
Table & \multicolumn{4}{c}{Fields} \\
\hline
\multicolumn{1}{c|}{User} & \underline{userId} & email & username & hashedPwd\\
\multicolumn{1}{c|}{Zone} & \underline{zoneId} & floor & maxCapacity & label\\
\multicolumn{1}{c|}{Node} & \underline{nodeId} & zoneId & floor & label\\
\multicolumn{1}{c|}{ReceivedSignal} & \underline{userId} & \underline{nodeId} & RSS & \underline{timestamp}\\
\multicolumn{1}{c|}{UserPosition} & \underline{positionId} & \underline{userId} & RSS & \underline{timestamp}\\
\multicolumn{1}{c|}{TrainingSet} & zoneId & zoneLabel & RSS[~] & timestamp[~]\\
\multicolumn{1}{c|}{TrainingSetDiff} & zoneId & zoneLabel & DiffRSS[~] & timestamp[~]\\
\hline
\end{tabular}
\end{table}


\subsection{Fingerprinting Algorithms}
\label{subsec:algorithms}
The localization algorithm in charge of estimating the position of each detected user has been implemented on the back-end using the JavaScript SDK provided by Parse Server.

The fingerprinting technique is based on a preliminary offline phase in which the building administrator create the training set for the algorithm. More specifically, the training procedure provides the creation of a label for each building zone (For example, \verb|OFFICE_1| or \verb|MEETING_ROOM|). Then the administrator needs to visit each building zone and declare the correct room label. During ground truth collection, the application asks to the administrator to remain stationary if the zone is tiny ($< 15 - 20m^2$) or walk around slowly if the zone is bigger. Meanwhile, on the server side, the RSS samples coming from the admin application are collected and stored in the training set together with the corresponding ground truth location. For each location, the number of vector collected must be at least 4; otherwise the fingerprinting for that location is considered incomplete.

\smallskip
The simplest, or \emph{baseline}, training set schema (represented by the TrainingSet entry in database \ref{tab:db}) is those illustrated in the following example (table \ref{tab:sample-simple}):

\definecolor{blizzardblue}{rgb}{0.674, 0.92, 0.98}
\newcolumntype{a}{>{\columncolor{blizzardblue}}c}


\begin{table}[h!tb]
\caption[Example of RSS samples captured during a training phase.]{Example of RSS samples captured during a training phase (baseline training set). Blue cells represent classification features.}
\label{tab:sample-simple}
\begin{center}
  \begin{tabular}{ | c | c | a | a | a | a |}
    \hline
    zoneLabel & zoneID & RSS1 & RSS2 & RSS3 & RSS4\\ \hline
    COFFEE ROOM & \verb|WTbiGlRdxu| & -60 & -81 & -85 & -95\\
    COFFEE ROOM & \verb|WTbiGlRdxu| & -62 & -80 & -86 & -89\\
    COFFEE ROOM & \verb|WTbiGlRdxu| & -70 & -82 & -91 & -96\\
    COFFEE ROOM & \verb|WTbiGlRdxu| & -63 & -81 & -87 & -93\\
    \hline
  \end{tabular}
\end{center}
\end{table}

Using this schema, the zone identifier and the RSS values represent the features of the classification algorithm.
The training samples reported above have been collected with the configuration depicted in figure \ref{fig:necst-sketch}.

\begin{figure}[h!tb]
\centering
\includegraphics[width=0.8\linewidth]{necst-sketch.pdf}
\caption[Configuration of the system during collection of samples reported in table \ref{tab:sample-simple}.]{Configuration of the system during collection of samples reported in table \ref{tab:sample-simple}.}
\label{fig:necst-sketch}
\end{figure}


Observing the configuration, and thinking on what is the aim of the training phase, a critical issue raises up. The features of the training set are strictly dependent on the particular mobile device where the learning procedure is executed. More specifically, the system will store batches of RSS values that depend not only on the current position, but also on the transmission power of the onboard BLE antenna.
The presence of a hardware dependent classification feature makes the system unreliable when the mobile device that need to be localized at runtime is different from the device used for the training procedure.\\
For this reason, a training set that differs from the \textbf{baseline} has been investigated. The classification algorithm has been trained using \textbf{differential} RSS samples, as shown in table \ref{tab:sample-simple}. In order to make the fingerprinting as more as possible independent from the mobile hardware, the algorithm performs classification based on the difference between RSS values captured at the same time from different nodes. 
The purpose of the differential training set is to reduce the correlation of each vector with the transmission power of the training device, while emphasize the proportions of the RSS vector elements.

\begin{table}[h!tb]
\caption[Example of differential RSS values captured during a training phase.]{Example of differential RSS values captured during a training phase. Blue cells represents classification features. DiffXY represents the difference between the signal strength received at node X and those received by node Y.}
\label{tab:sample-diff}
\begin{center}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\setlength{\tabcolsep}{.35em}
  \begin{tabularx}{\textwidth}{ | Y | Y | a | a | a | a | a | a |}
    \hline
    zoneLabel & zoneID & Diff12 & Diff13 & Diff14 & Diff23 & Diff24 & Diff34\\ \hline
    COFFEE ROOM & \verb|WTbiGlRdxu| & 21 & 25 & 35 & 4 & 14 & 10\\
    COFFEE ROOM & \verb|WTbiGlRdxu| & 18 & 24 & 27 & 6 & 9 & 3\\
    COFFEE ROOM & \verb|WTbiGlRdxu| & 12 & 21 & 26 & 9 & 14 & 5\\
    COFFEE ROOM & \verb|WTbiGlRdxu| & 12 & 21 & 26 & 9 & 14 & 5\\
    \hline
  \end{tabularx}
\end{center}
\end{table}

The training set has been used to train the following classification algorithms.

\subsubsection{K Nearest Neighbor}
\label{subsubsec:knn}
For the KNN algorithm, each vector of the training set is virtually positioned in a D-dimensional space, where D is the dimension of the vector. Since in our testbed there have been employed 4 sensor nodes, the space has dimension 4 for the baseline training set, and dimension 6 for the differential set.

At run time, the algorithm builds the RSS vector using the user ID and the timestamps of the samples that fall within a short sliding window (1 - 2 seconds). This guarantees that each sample of the vector comes from the same location in the building, since the user can't change position a short window of time.
Whenever a new unlabeled vector is constructed, the algorithm put the element on the virtual graph. At this point, a set of K training points that are the K closest points to the runtime point are selected. From the K labeled observations, a majority vote determines the position label of the runtime sample. The implemented algorithm selects $K=5$ training observations.
The distance between two points $a$ and $b$ (where for instance $a$ is labeled and $b$ is unlabeled) is computed using the Euclidean distance ($E$ for the baseline while $E'$ for the differential case):

\begin{equation}\label{eq:E-baseline}
E(a,b)=\sqrt{(rss_{a,1} - rss_{b,1})^2 + ... + (rss_{a,k} - rss_{b,k})^2}
\end{equation}
\begin{equation}\label{eq:E-differential}
E'(a,b)=\sqrt{(diff_{a,12} - diff_{b,12})^2 + ... + (diff_{a,jk} - diff_{b,jk})^2}
\end{equation}

In equation \ref{eq:E-baseline}, $rss_{a,1}$ represents the RSS value captured by node 1 and stored in the training vector $a$. In equation \ref{eq:E-differential}, $Diff_{a,12}$ represents the difference between training RSS sample of node 1 and node 2, and stored in the training vector $a$.

\medskip
The implemented algorithm computes the distance $E(a,b)$ for every vector $a$ belonging to the training set, sorts in increasing order the resulting list of distances and select the firsts 5 elements for the majority vote. Defining $N$ as the dimension of the training set, and $d$ the dimension of each sample, the resulting time complexity to estimate the position each time is $O(dN + NlogN)$.

%TODO: parlare dei dati mancanti

\subsubsection{Decision Trees}
\label{subsubsec:trees}
For Decision Trees algorithm, each (baseline) RSS vector has been normalized using the Min-Max scaling. Each normalized element $\widetilde{rss_i}$ has been computing using the following equation (\ref{eq:norm}), where $rss_i$ is the raw sample, while $\vec{rss}$ is the entire RSS training set:

\begin{equation}\label{eq:norm}
\widetilde{rss_i} = \frac{rss_i - min(\vec{rss})}{max(\vec{rss}) - min(\vec{rss})}
\end{equation}

For each feature, a splitting attribute $s$ has been defined as the mean value from the entire data set of that feature. The splitting attribute is used to identify a runtime value as low if it is lower than $s$, or high if it is equal or higher than $s$.

Successively, in order to build a valid decisional tree, the following procedure has been applied to each feature and for each classification in turn. Consider the feature $\widetilde{rss_1}$ and the classification "COFFEE ROOM". The feature has two possible values: low and high. Some of the training samples are low, and we call this set of samples $LOW$. Other samples have been identified as high, and we define this set as $HIGH$. for each one of the two sets, an histogram is built over the classification label "COFFEE ROOM", as shown in figure \ref{fig:tree}.

\begin{figure}[h!tb]
\centering
\includegraphics[width=\linewidth]{tree.pdf}
\caption[Example of data normalization using Min-Max scaling.]{Example of data normalization using Min-Max scaling. The histogram shows frequency for each one of the \emph{bucket}.}
\label{fig:tree}
\end{figure}

 Now it's possible to check how much the "COFFEE ROOM" classification is correct if the guess is made exclusively on the $\widetilde{rss_1}$ feature.
In the HIGH set the classification performs 100\% correctly. In the LOW set the classification performs 70\% of them correctly, while 30\% wrong. So overall you would classify 17 out of 20 correctly (85\%). Thus, we can say that the \emph{score} of the $\widetilde{rss_1}$ feature is 85\%. 

The mentioned score is used to sort all the features from the highest to the lowest score, and the order is used to build the decision tree, applying each time the subsequent feature.\\
The procedure explained however, provide the binary classification that localizes the user inside coffee room or outside coffee room. To obtain the multi-class classification that identify the correct building zone, it is possible to apply the binary classifier repeatedly and combine the results to get the multi-class classification.

We define $N$ as the dimension of the training set, while $d$ the number of feature for each samples ($d=4$ for baseline dataset, $d=6$ for differential dataset). The resulting time complexity of the decisional trees implemented is $O(d^2N)$, almost one order of magnitude better than KNN.

% SPLITTO RANGE IN PIU DI DUE INTERVALLI. CANCELLARE SE ALBERI NON BINARI è SBAGLIATO
% After normalization, each RSS vector is composed by values that can range from \numrange{0}{1}. The range has been dived in 5 \emph{buckets} (0.0-0.2, 0.2-0.4, 0.4-0.6, 0.6-0.8, 0.8-1.0) as shown by the example in figure \ref{fig:norm}:

% \begin{figure}[h!tb]
% \centering
% \includegraphics[height=11cm, width=13cm]{norm.png}
% \caption[Example of data normalization using Min-Max scaling.]{Example of data normalization using Min-Max scaling. The histogram shows frequency for each one of the \emph{bucket}.}
% \label{fig:norm}
% \end{figure}
% Successively, in order to build a valid decisional tree, the following procedure has been applied to each feature and for each classification in turn. Consider the feature $\widetilde{rss_1} > 0.8$ and the classification "COFFEE ROOM". The feature has two possible value: no and yes. Some of the training samples have an answer "no", and we call this set of samples $CR$. Other samples have an answer yes, and we define this set as $Y$. for each



\section{Integration with a Thermal Comfort System}
\label{sec:thermosense}

\begin{figure}[h!tb]
\center
\includegraphics[width=0.3\linewidth]{tsscreenshot.pdf}
\captionof{figure}[ThermoSense user interface that collects thermal complaints from building occupants.]{ThermoSense mobile application user interface.}
\label{fig:thermoUI}
\end{figure}

BlueSentinel has been integrated with \emph{ThermoSense}
\footnote{ThermoSense project: \url{http://box.necst.it/thermosense.html}}, a thermal comfort system developed in our laboratory.\\
The mobile application described in section \ref{sec:app} has been used in conjunction with BlueSentinel and ThermoSense. In particular, while the BlueSentinel module manages all the Bluetooth functionalities, ThermoSense module collects information on the current thermal comfort of the tenants. Users are able to provide a thermal comfort feedback (a complaint) that quantifies the amount of cold or hot perceived through a gradient interface. The feedback information, together with the user position detected by BlueSentinel, is used by ThermoSense to compute the best possible HVAC set point to satisfy the occupants comfort while minimizing the building consumption.
The position information is retrieved by the decisional engine of ThermoSense directly on the backend level. However, any other smart building application developed as a third-party components can retrieve the building occupancy information using the REST interface explained in section \ref{sec:back-end}.

%TODO: spostare, declassare o cancellare
%\section{Real-World Deployed System}
%\label{sec:lab}

\section{Web-Based Monitoring Dashboard}
\label{sec:webmonitor}
The occupancy information computed by BlueSentinel has been visualized in a monitoring web page. The page shows location data in three different forms.\\
First a text table reports the current number of occupants for each zone or room (figure \ref{fig:monitor-text}). Together with the occupants number, is available the time instant in which the last user has been seen in the zone.

\begin{figure}[h!tb]
\center
\includegraphics[width=0.7\linewidth]{monitor-text.pdf}
\captionof{figure}[Number of occupants per room from the web based monitor page.]{Number of occupants per room from the web based monitor page.}
\label{fig:monitor-text}
\end{figure}

The real-time occupancy is also reported in a heat-map that represents the population distribution inside the indoor environment (figure \ref{fig:monitor-rooms}). The heat-map shows in dark red the more populated zones, while in yellow and white semi-empty or empty rooms.

\begin{figure}[h!tb]
\center
\includegraphics[width=\linewidth]{monitor-rooms.pdf}
\captionof{figure}[Occupants distribution of the building on a heatmap.]{Occupants distribution of the building on a heatmap.}
\label{fig:monitor-rooms}
\end{figure}

Another chart has been used to visualized the occupancy history of each building zone (figure \ref{fig:monitor-history}). Each line represents the number of people in a room as a function of the time.

\begin{figure}[h!tb]
\center
\includegraphics[width=\linewidth]{monitor-history.pdf}
\captionof{figure}[Occupancy history of the building on a line chart.]{Occupancy history of the building on a line chart.}
\label{fig:monitor-history}
\end{figure}

In all the dashboard elements, users identity has never been showed to guarantee the occupants privacy.


\section{Limitations}
\label{sec:limitations}
%advertising background for ios. backwards compatibility android. --> detection delays
A first limitation of the proposed approach regards the numerous mobile devices that doesn't support BLE advertising. These can be classified in two categories: devices presenting a version of Bluetooth lower than 4.0 (non BLE), or devices supporting BLE but without a built-in peripheral chipset.\\
For both these two cases, a workaround as been exploited in the BlueSentinel system to provide a backward compatibility to older devices. At this purpose, when the Android application detects the lack of advertising support, it edits the so called Bluetooth friendly-name, i.e. the string that the device provide for pairing with surrounding objects (for example "Andrea's phone"). The friendly name is edited so that it contains the userID and BlueSentinel token introduced in section \ref{sec:app}. In addition, the application edits the Bluetooth discoverability time setting it to infinite.\\
The workaround allows the system to extend the compatibility to older devices; however present some drawbacks. First, the sensor nodes (section \ref{sec:wsn}) showed that using this method the discovery time required to detect the devices is higher compared to BLE advertisement, ranging from 2 to 10 seconds. Second, extending the Bluetooth discoverability of the devices is discouraged since can cause security issues.

\smallskip
Another limitation of the proposed approach relies in the possibility to perform Bluetooth LE advertising on iOS devices when the phone is in background state, i.e. when the screen is off.
The Apple documentation states that all service UUIDs contained in the value of the \verb|AdvertisementDataServiceUUIDsKey| advertisement key are placed in a special “overflow” area; they can be discovered only by an iOS device that is explicitly scanning for them. Nevertheless, the iOS developer community has proven that it's possible to access the advertisement key through a BLE advertisement inquiry performed by the scanning device. Unfortunately, during the development of the BlueSentinel sensor nodes, this particular BLE inquiry has revealed to be unsupported by the current BLE libraries for Raspberry Pi boards. However, moving from the single board computer implementation to a more specific hardware nodes, for example a microcontroller based board, could allow a lower level management of the Bluetooth protocol stack.

\section{Conclusions}
\label{sec:conclusion}

In this chapter, the proposed BLE occupancy monitoring system has been described. First, the feasibility study is reported, explaining also the reasons of the adopted design and the technology employed. Then, the architecture of the system has been illustrated, passing through application, sensing and back-end layers.\\
On the application side, has been discussed the potentiality and limitations of the BLE signal advertisement of recent smartphones, one of the key functionalities exploited in our system. Successively, at sensors level, have been discussed the methods of synchronization and signal filtering implemented. For the back-end side, are reported the database employed for the system, and the different classification methods utilized for users localization. In addition will be also illustrated how the occupancy information has being visualized in a web application.

The key contribution of the proposed system are:
\begin{enumerate*}[label={\textbf{(\arabic*)}}]
\item extremely low battery consumption of the mobile application that allows the system to run continuously for many hours;
\item the occupancy detection in real-time;
\item an approach that is non-intrusive from the user point of view;
\item simplified installation and training assisted by a mobile application for building administrator.
\end{enumerate*}

Finally, some limitations of the implemented system have been presented, together with possible approaches to overcome these issues.

%
% -----------------------------END------------------------------------- %